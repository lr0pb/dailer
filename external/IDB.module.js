class IDB{constructor(e,t,s,r={}){return this._options=r,this._listeners={},this._idb=indexedDB.open(e,t),this._idb.addEventListener("upgradeneeded",(()=>this._upgradeneeded(s))),this._idb.addEventListener("success",(()=>this._success())),this}_upgradeneeded(e){this._options.showLogs&&console.log("[IDB] Database upgrading started"),this.db=this._idb.result;const t={};for(let s of e)this.db.objectStoreNames.contains(s.name)||this.db.createObjectStore(s.name,s.index),t[s.name]=!0;for(let e of this.db.objectStoreNames)t[e]||this.db.deleteObjectStore(e)}_success(){this._options.showLogs&&console.log("[IDB] Database successfully opened"),this.db=this._idb.result,this.db.addEventListener("versionchange",(()=>this._versionchange()))}_versionchange(){this.db.close(),this._closedDueToVersionChange=!0,this._throwError(!0,"[IDB] Database closed due to version change, reload page")}async _isDbReady(){return!this._closedDueToVersionChange&&(this.db||await new Promise((e=>{const t=()=>{this.db?e():requestAnimationFrame(t)};t()})),!0)}_err(e,t){return`[IDB] Error in db.${e}(${t||" "}): `}_throwError(e,t){const s=e?console.error:console.warn;if(!(!e||this._options.showErrorsAsLogs&&e))throw new Error(t);s(t)}_checkStore(e,t){return!!this.db.objectStoreNames.contains(t)||this._throwError(!0,`${this._err(e)}database haven't "${t}" store`)}async _dbCall(e,t,s,r,a,n){if(!await this._isDbReady())return;if(!this._checkStore(e,t))return;const i=this.db.transaction(t,s),o=i.objectStore(t),l=[];if(Array.isArray(a)||(a=[null!=a?a:null]),a&&Array.isArray(a))for(const e of a){const t=o[r](e);t.addEventListener("success",(async()=>{const e=t.result;if(!e)return l.push(void 0);const s=n?await n(e):e;void 0!==s&&l.push(s)}))}return new Promise((e=>{i.addEventListener("complete",(async()=>{e(1==l.length?l[0]:l)}))}))}async _onDataUpdateCall(e,t,s){if(e in this._listeners)for(let r in this._listeners[e])await this._listeners[e][r]({store:e,type:t,item:s})}async set(e,t){const s=await this._dbCall("setItem",e,"readwrite","put",t,(async t=>(await this._onDataUpdateCall(e,"set",t),!0)));return 1==(null==s?void 0:s.length)?s[0]:s}async get(e,t){const s=await this._dbCall("getItem",e,"readonly","get",t);return 1===(null==s?void 0:s.length)?s[0]:s}async update(e,t,s){Array.isArray(t)||(t=[t]),Array.isArray(s)||(s=[s]);const r=this._err("update",e);if(1!==s.length&&t.length!==s.length)return this._throwError(!0,`${r}UpdateCallbacks length should be the same as itemKeys or should be only one UpdateCallback`);let a=await this.get(e,t);if(a){if(Array.isArray(a)||(a=[a]),!a.length||a.length!==t.length)return this._throwError(!0,`${r}Cannot update items with given keys, because not all items exist`);for(let e=0;e<a.length;e++)await s[1==s.length?0:e](a[e]);return await this.set(e,a),1==a.length?a[0]:a}}async getAll(e,t){let s=0,r=await this._dbCall("getAll",e,"readonly","openCursor",null,(e=>{if(!e)return;const r=e.value;return t&&t(r,s),s++,e.continue(),r}));return Array.isArray(r)?r.pop():r=[],r}async delete(e,t){await this._dbCall("deleteItem",e,"readwrite","delete",t,(async()=>{await this._onDataUpdateCall(e,"delete")}))}async deleteAll(e){await this._dbCall("deleteAll",e,"readwrite","clear",null,(async()=>{await this._onDataUpdateCall(e,"deleteAll")}))}async has(e,t){let s=await this._dbCall("hasItem",e,"readonly","count",t);if(t){Array.isArray(s)||(s=[s]);const e=[];for(const t of s)e.push(1===t);return 1==e.length?e[0]:e}return"number"==typeof s?s:0}async onDataUpdate(e,t){if(!await this._isDbReady())return;if(!this._checkStore("onDataUpdate",e))return;e in this._listeners||(this._listeners[e]={});const s=Date.now();return this._listeners[e][s]=t,()=>{delete this._listeners[e][s]}}}export{IDB};
